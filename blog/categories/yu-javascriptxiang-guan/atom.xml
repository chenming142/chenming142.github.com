<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 与JavaScript相关 | chenming142's Blog for github]]></title>
  <link href="http://chenming142.github.com/blog/categories/yu-javascriptxiang-guan/atom.xml" rel="self"/>
  <link href="http://chenming142.github.com/"/>
  <updated>2013-03-19T07:35:48+08:00</updated>
  <id>http://chenming142.github.com/</id>
  <author>
    <name><![CDATA[Kevin Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[jQuery 数据类型详解]]></title>
    <link href="http://chenming142.github.com/blog/2013/03/17/jquery-type/"/>
    <updated>2013-03-17T15:31:00+08:00</updated>
    <id>http://chenming142.github.com/blog/2013/03/17/jquery-type</id>
    <content type="html"><![CDATA[<blockquote><p>ECMAScript中有5种基本数据类型:Undefined,Null,Boolean,Number和String.还有一种复杂数据类型——Object,Object本质上是由一组无序的名值对组成的.</p></blockquote>

<h3>typeof 操作符</h3>

<p>对一个值使用typeof操作符可能返回下列某个字符串:<br/>
"undefined" —— 如果这个值未定义<br/>
"boolean" —— 如果这个值是布尔值<br/>
"string" —— 如果这个值是字符串<br/>
"number" —— 如果这个值是数值<br/>
"object" —— 如果这个值是对象或null<br/>
"function" —— 如果这个值是函数</p>

<pre><code>注:typeof 操作符的操作数可以是变量,也可以是数值字面量.typeof是操作符而非函数.
</code></pre>

<!--more-->


<p></p>

<h3>使用库进行判断数据类型</h3>

<pre><code>(function($, S, undefined){
    var host = this,
        class2type = {}, // [[Class]] -&gt; type pairs
        OP = Object.prototype,
        toString = OP.toString,
        hasOwn = OP.hasOwnProperty,
        TRUE = true,FALSE = false;
    $ = host &amp;&amp; ( host[$] = {} ) ;

    var hasEnumBug = !({toString:1}.propertyIsEnumerable('toString')),
        emumProperties = [
            'hasOwnProperty',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'toString',
            'toLocaleString',
            'valueOf'
        ],
        meta = {
            /**
             * Copies all the properties of s to r
             * @param r
             * @param s
             * @param ov
             * @param wl
             * @param deep
             * @return {*}
             */
            mix : function(r, s, ov, wl, deep){
                if(!s || !r){return r;}
                if(ov === undefined){ov = true;}
                var i, p, len;
                if(wl &amp;&amp; (len = wl.length)){
                    for(i = 0; i &lt; len; i++){
                        p = wl[i];
                        if( p in s){_mix(p, r, s, ov, deep);}
                    }
                }else{
                    for(p in s){
                        _mix(p, r, s, ov, deep);
                    }
                    if(hasEnumBug){
                        for (var j = 0; j &lt; emumProperties.length; j++) {
                            p = emumProperties[j];
                            if (ov &amp;&amp; hasOwn.call(s, p)) {
                                r[p] = s[p];
                            }
                        }
                    }
                }
                return r;
            }
        },
        _mix = function(p, r, s, ov, deep){
            if(ov || !(p in r)){
                var target = r[p], src = s[p];
                if(target === src){return ;}
                if( deep &amp;&amp; src &amp;&amp; (S.isArray(src)) ){
                    var clone = target &amp;&amp; (S.isArray(target) || S.isPlainObject(target)) ?
                        target :
                        ( S.isArray(src) ? [] : {});
                    r[p] = S.mix( clone, src, ov, undefined);
                }else if( src !== undefined ){
                    r[p] =s[p];
                }
            }
        },
        seed = ( host &amp;&amp; host[S] ) || {};
    S = host[S] = meta.mix( seed, meta );

    /**
     * If the type of val is null, undefined, number, string, boolean, return true.
     * @param val
     * @return {Boolean}
     */
    function isValidParamValue( val ){
        var t = typeof val;
        return val == null || ( t !== 'object' &amp;&amp; t !== 'function' );
    }
    S.mix(KISSY, {
        isNull : function( o ){
            return o === null;
        },
        isUndefined : function( o ){
            return o === undefined;
        },
        isEmptyObject : function(obj){
            for(var name in obj){
                if( name !== undefined ){
                    return FALSE;
                }
            }
            return TRUE;
        },
        isPlainObject : function(o){
            return o &amp;&amp; toString.call(o) === '[object Object]' &amp;&amp; 'isPrototypeOf' in o;
        },
        type : function( o ){
            return o == null ?
                String( o ) : class2type[ toString.call(o) ] || "object";
        },
        each : function(object, fn, context){
            if( object ){
                var key, val, i = 0,
                    length = object &amp;&amp; object.length,
                    isObj = length === undefined || S.type(object) === 'function';
                context = context || null;
                if( isObj ){
                    for( key in object ){
                        if( fn.call( context, object[key], key, object ) === FALSE ){
                            break;
                        }
                    }
                }else{
                    for (val = object[0];
                         i &lt; length &amp;&amp; fn.call(context, val, i, object) !== FALSE; val = object[++i]) {
                    }
                }
            }
            return object;
        }
    });
    S.each('Boolean Number String Function Array Date RegExp Object'.split(' '),function(name, lc){
        class2type['[object ' + name + ']'] = (lc = name.toLowerCase());
        S['is' + name] = function( o ){
            return S.type(o) == lc;
        }
    });

    $.extend = function( ){
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;
        if( typeof target === "boolean" ){
            deep = target;
            target = arguments[1] || {};
            i = 2;
        }
        if( typeof target !== "object" &amp;&amp; !$.isFunction(target)){
            target = {};
        }
        if( length === i ){//extend jQuery itself
            target = this;
            --i;
        }
        for( ; i &lt; length; i++){
            if( (options = arguments[i]) != null ){
                for( name in options ){
                    src = target[ name ];
                    copy = options[ name ];
                    if( target === copy ){continue;}
                    if( deep &amp;&amp; copy &amp;&amp; ( $.isPlainObject(copy) || ( copyIsArray = $.isArray(copy) ) ) ){
                        if( copyIsArray ){
                            copyIsArray = false;
                            clone = src &amp;&amp; $.isArray(src) ? src : [];
                        }else{
                            clone = src &amp;&amp; $.isPlainObject(src) ? src : {};
                        }
                        target[ name ] = $.extend( deep, clone, copy );
                    }else if( copy !== undefined ){
                        target[ name ] = copy;
                    }
                }
            }
        }
        return target;
    };
    $.extend({
        isFunction :function(obj){
            return $.type(obj) === 'function';
        },
        isArray : Array.isArray || function(obj){
            return $.type(obj) === 'array';
        },
        isNumeric : function(obj){
            return !isNaN( parseFloat(obj) ) &amp;&amp; isFinite(obj);
        },
        isWindow : function(obj){
            return obj != null &amp;&amp; obj == obj.window;
        },
        type : function( o ){
            return o == null ?
                String( o ) : class2type[ toString.call(o) ] || "object";
        },
        isEmptyObject : function(obj){
            for(var name in obj){
                if( name !== undefined ){
                    return FALSE;
                }
            }
            return TRUE;
        },
        isPlainObject : function(obj){
            if( !obj || $.type(obj) !== "object" || obj.nodeType || $.isWindow(obj) ){
                return false;
            }
            try{
                if( obj.constructor &amp;&amp;
                    !hasOwn.call(obj, "constructor") &amp;&amp;
                    !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")){
                    return false;
                }
            } catch (e){
                return false;
            }
            var key;
            for( key in obj ){}
            return key === undefined || hasOwn.call( obj, key );
        },
        each : function( object, callback, args ){
            var name, i = 0,
                length = object.length,
                isObj = length === undefined || $.isFunction( object );
            if( args ){
                if( isObj ){
                    for( name in object ){
                        if( callback.apply( object[name] , args) === false ){break;}
                    }
                }else{
                    for( ; i &lt; length; ){
                        if( callback.apply( object[i++], args) === false){break;}
                    }
                }
            }else{
                if ( isObj ) {
                    for ( name in object ) {
                        if ( callback.call( object[ name ], name, object[ name ] ) === false ) {break;}
                    }
                } else {
                    for ( ; i &lt; length; ) {
                        if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {break;}
                    }
                }
            }
            return object;
        }
    });
    $.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name){
        class2type[ "[object "+ name +"]" ] = name.toLowerCase();
    });
})('jQuery', 'KISSY', undefined);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jquery unique 详解]]></title>
    <link href="http://chenming142.github.com/blog/2013/03/15/jquery-unique/"/>
    <updated>2013-03-15T21:22:00+08:00</updated>
    <id>http://chenming142.github.com/blog/2013/03/15/jquery-unique</id>
    <content type="html"><![CDATA[<blockquote><p>最近在工作中使用到了jquery.unique函数,用的过程中出现了很多偏差,所以就查看了jquery源码现在总结一下.</p></blockquote>

<p>先看看jQuery.unique(array)api是:</p>

<pre><code>删除数组中重复元素.只处理删除DOM元素数组,而不能处理字符串或者数字数组.
</code></pre>

<p>再来看看jquery.unique的测试结果:<br/>
<img src="/images/common/2013-03-15-jquery-unique/20130315214713.jpg" title="jquery-1.4.unique" alt="jquery-1.4" />
[<strong>jquey-1.4</strong>] <br/>
<img src="/images/common/2013-03-15-jquery-unique/20130315214630.jpg" title="jquery-1.7.2.unique" alt="jquery-1.7" />
[<strong>jquey-1.7.2</strong>]</p>

<p>从测试结果看,1.4版本虽未能够完美实现去除重复元素,但是某些情况(即数组是有序的)下也是能处理数值和字符型数值数组的;而1.7.2版已能完美支持了.</p>

<h3>去除重复元素的实现方法</h3>

<pre><code>$ = function() {
    return {
        unique1: function(elems) {
            for (var i = 0; i &lt; elems.length; ++i) {         // 外层++i
                for (var j = i + 1; j &lt; elems.length; ++j) { // 内层j = i +1
                    if (elems[i] === elems[j]) {             // 判断是否重复的
                        elems.splice(i--, 1);                // 如果重复,就去掉
                        break;                               // i-- 与break,保证外层始终从0开始
                    }
                }
            }
            return elems;
        },
        unique2: function(elemsWithId) {
            var obj = {};
            for (var i = 0; i &lt; elemsWithId.length; ++i) {
                var elem = elemsWithId[i];
                obj[elem.getAttribute('id')] = obj[elem.getAttribute('id')] || elem;
            }
            elemsWithId.length = 0;
            for (var id in obj) {
                elemsWithId.push(obj[id])
            }
            return elemsWithId;
        }
    }
}();
</code></pre>

<p>方法一使用了两重循环,算法复杂度为<code>O(n^2)</code>.实现思路比较直观,即遍历数组,看每个元素是否与后面的元素重复,有重复则移除;但是DOM Element数量较多时性能较差,而jQuery中对大量元素进行去除重复的操作很普遍. <br/>
方法二将Objct当做HashMap/HashSet来使用,算法复杂度为<code>O(n)</code>;遗憾的是JavaScript中无法直接用DOM Element作为Object的key,因此只能将id作为key,然而并非所有的 DOM Element 都是有id 的，所以这种方法并不通用。</p>

<!-- more -->


<p>我们知道,基于比较的排序算法最多可以将算法复杂度降到<code>O(nlgn)</code>，（比如结合使用快速排序和插入排序），之后遍历数组时只要比较相邻元素就可以了：</p>

<pre><code>unique3: function(sortedElems) {
    for ( var i = 1; i &lt; sortedElems.length; i++ ) {
        if ( sortedElems[i] === sortedElems[ i - 1 ] ) {
            sortedElems.splice( i--, 1 );
        }
    }
    return sortedElems;
}
</code></pre>

<p>JavaScript中有内置的排序算法。因此，在JavaScript中，先排序后去除重复是较好的做法。</p>

<h3>先排序后去除重复</h3>

<pre><code>var sortOrder, siblingCheck;
sortOrder = function( a, b ) {
    var al, bl,
        ap = [],
        bp = [],
        aup = a.parentNode,
        bup = b.parentNode,
        cur = aup;
    // If the nodes are siblings (or identical) we can do a quick check
    if ( aup === bup ) {
        return siblingCheck( a, b );
    // If no parents were found then the nodes are disconnected
    } else if ( !aup ) {
        return -1;
    } else if ( !bup ) {
        return 1;
    }
    // Otherwise they're somewhere else in the tree so we need
    // to build up a full list of the parentNodes for comparison
    while ( cur ) {
        ap.unshift( cur );
        cur = cur.parentNode;
    }
    cur = bup;
    while ( cur ) {
        bp.unshift( cur );
        cur = cur.parentNode;
    }
    al = ap.length;
    bl = bp.length;
    // Start walking down the tree looking for a discrepancy
    for ( var i = 0; i &lt; al &amp;&amp; i &lt; bl; i++ ) {
        if ( ap[i] !== bp[i] ) {
            return siblingCheck( ap[i], bp[i] );
        }
    }
    // We ended someplace up the tree so do a sibling check
    return i === al ?
        siblingCheck( a, bp[i], -1 ) :
        siblingCheck( ap[i], b, 1 );
};
siblingCheck = function( a, b, ret ) {
    if ( a === b ) {
        return ret;
    }
    var cur = a.nextSibling;
    while ( cur ) {
        if ( cur === b ) {
            return -1;
        }
        cur = cur.nextSibling;
    }
    return 1;
};
</code></pre>

<p>使用Array内置的sort 方法,并传入了自定义的排序函数sortOrder. <br/>
sortOrder函数的做法是:获取两个被比较元素的所有"直系祖宗",从而确定两个元素在DOM树种的位置;一般来说,两个元素有共同的根,那么就从根元素开始依次向下遍历,直到"分叉点",再对分叉点的元素进行比较.如果直到遍历结束,仍未能到达分叉点(如元素a先遍历,那么i就与al相等),则直接将a与b当前遍历到的"祖宗"进行比较.</p>

<h3>排序时进行检查</h3>

<p>优化:先判断元素中是否存在重复的,如果元素不重复,那么就可以不执行后面的遍历并去除重复操作了.实现如下:</p>

<pre><code>var hasDuplicate = false,
    baseHasDuplicate = true;
[0, 0].sort(function(){
    baseHasDuplicate = false;
});
var uniqueSort = function( results ) {
    if ( sortOrder ) {
        hasDuplicate = baseHasDuplicate;
        results.sort( sortOrder );
        if ( hasDuplicate ) {
            for ( var i = 1; i &lt; results.length; i++ ) {
                if ( results[i] === results[ i - 1 ] ) {
                    results.splice( i--, 1 );
                }
            }
        }
    }
    return results;
};
</code></pre>

<p>一个特殊的例外是某些浏览器可能进行了特殊的优化，那么在元素相等时可能就没有调用我们的排序函数了；这种情况下，排序时检查重复的方案就不可行。因此，如果浏览器在元素相等的情况下会调用我们的排序函数，那么就将 hasDuplicate 置为 false，并在排序过程中检查重复；否则，无论如何都视为存在重复，仍然进行遍历去除重复的操作。</p>

<h3>使用compareDocumentPosition()进行优化</h3>

<p>事实上，除 IE 之外浏览器都有内置的 compareDocumentPosition() 方法，用于比较两个 DOM Element 的位置，因此我们可以引入 compareDocumentPosition() 进行优化:</p>

<pre><code>if (document.documentElement.compareDocumentPosition) {
    var sort = function(a, b) {
        if (a === b) {
            hasDuplicate = true;
            return 0;
        }
        if (!a.compareDocumentPosition || !b.compareDocumentPosition) {
            return a.compareDocumentPosition ? -1 : 1;
        }
        return a.compareDocumentPosition(b) &amp; 4 ? -1 : 1;
    }
}
</code></pre>

<p>a.compareDocumentPosition(b) &amp; 4 表示取返回值的二进制表示的倒数第三位; <br/>
compareDocumentPosition() 的返回值的每个二进制位表示不同的含义，其中倒数第三位表示元素 a 是否在元素 b 的 “前面”</p>

<p>jQuery 的 unique() 在去除重复前先进行了排序，并使用了多种优化手段，实现了性能较好并且比较通用的去除重复的 DOM Element 的功能。</p>

<h3>最后的最后</h3>

<p><img src="/images/common/2013-03-15-jquery-unique/20130315234659.jpg" title="ff jquey-1.7" alt="ff jquery-1.7" />
[<strong>ff jquery-1.7</strong>]
这又是什么原因,你知道了吗?</p>
]]></content>
  </entry>
  
</feed>
